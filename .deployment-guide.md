# Deployment Guide

## Option 1: Deploy to Render (Recommended - Simplest)

Since this application serves both frontend and backend from the same Express server, deploying to Render is the simplest option.

### Steps:

1. **Create a Render account** at [render.com](https://render.com)

2. **Create a new Web Service**:
   - Click "New +" → "Web Service"
   - Connect your GitHub/GitLab repository
   - Or use "Deploy from Git URL"

3. **Configure the service**:
   - **Name**: collaborative-canvas
   - **Environment**: Node
   - **Build Command**: `npm install`
   - **Start Command**: `npm start`
   - **Plan**: Free (or paid for better performance)

4. **Deploy**:
   - Click "Create Web Service"
   - Render will automatically deploy your app
   - You'll get a URL like: `https://collaborative-canvas.onrender.com`

5. **Test**:
   - Open the URL in multiple browser tabs
   - Start drawing and test real-time collaboration

### Using the render.yaml file:

Alternatively, you can use the included `render.yaml` file:

1. Push your code to GitHub
2. In Render dashboard, click "New +" → "Blueprint"
3. Connect your repository
4. Render will automatically detect `render.yaml` and configure everything

---

## Option 2: Deploy to Railway

[Railway](https://railway.app) is another great option for Node.js apps.

### Steps:

1. **Create a Railway account**

2. **Create new project**:
   - Click "New Project"
   - Select "Deploy from GitHub repo"
   - Connect your repository

3. **Configure**:
   - Railway will auto-detect Node.js
   - It will automatically use the `start` script from package.json

4. **Generate domain**:
   - Go to "Settings" → "Generate Domain"
   - You'll get a URL like: `https://collaborative-canvas.up.railway.app`

---

## Option 3: Deploy to Heroku

### Steps:

1. **Install Heroku CLI**

2. **Login and create app**:
```bash
heroku login
heroku create collaborative-canvas
```

3. **Deploy**:
```bash
git push heroku main
```

4. **Open app**:
```bash
heroku open
```

---

## Option 4: Separate Frontend/Backend Deployment

If you want to deploy frontend and backend separately:

### Backend (Render/Railway/Heroku):
Follow any of the above methods to deploy the Node.js server.

### Frontend (Vercel/Netlify):

1. **Update websocket.js**:
```javascript
// Change this line in client/websocket.js
constructor(serverUrl) {
    // Replace with your deployed backend URL
    this.socket = io('https://your-backend-url.onrender.com');
}
```

2. **Deploy to Vercel**:
```bash
cd client
vercel --prod
```

3. **Deploy to Netlify**:
   - Drag and drop the `client` folder to Netlify
   - Or use Netlify CLI:
```bash
cd client
netlify deploy --prod
```

4. **Configure CORS on backend**:

Add to `server/server.js`:
```javascript
const io = socketIo(server, {
    cors: {
        origin: 'https://your-frontend-url.vercel.app',
        methods: ['GET', 'POST']
    }
});
```

---

## Environment Variables

This application doesn't require any environment variables by default. However, you may want to set:

- `PORT`: Server port (default: 3000) - Most platforms set this automatically
- `NODE_ENV`: Set to "production" for production deployments

On Render/Railway/Heroku, the `PORT` is automatically set by the platform.

---

## Post-Deployment Testing

1. Open your deployed URL in 2+ browser tabs
2. Draw in one tab, verify it appears in others in real-time
3. Test cursor sharing by moving your mouse in different tabs
4. Test undo/redo across multiple tabs
5. Verify the user list updates when you open/close tabs

---

## Monitoring and Logs

### Render:
- View logs in the Render dashboard under your service
- Click "Logs" tab to see real-time logs

### Railway:
- View logs in the Railway dashboard
- Click on your service → "View Logs"

### Heroku:
```bash
heroku logs --tail
```

---

## Scaling Considerations

The current implementation uses in-memory state, which means:

- ✅ Works great for single instance
- ❌ Won't work with multiple instances (horizontal scaling)

To scale horizontally, you'll need to:

1. **Add Redis for pub/sub**:
```javascript
const redis = require('socket.io-redis');
io.adapter(redis({ host: 'redis-server', port: 6379 }));
```

2. **Add MongoDB for persistence**:
   - Store operations in database
   - Load on server start
   - Enable recovery from crashes

3. **Use sticky sessions** on your load balancer

For most use cases, a single instance is sufficient.

---

## Custom Domain

### Render:
1. Go to service settings
2. Click "Custom Domains"
3. Add your domain and configure DNS

### Vercel/Netlify:
1. Go to project settings
2. Add custom domain
3. Update DNS records as instructed

---

## SSL/HTTPS

All recommended platforms (Render, Railway, Vercel, Netlify, Heroku) provide free SSL certificates automatically.

---

## Troubleshooting

**WebSocket connection fails:**
- Check that your backend is deployed and accessible
- Verify CORS settings if frontend/backend are on different domains
- Ensure you're using `wss://` (not `ws://`) for HTTPS sites

**Canvas doesn't sync:**
- Check browser console for errors
- Verify WebSocket connection is established
- Check server logs for errors

**Performance issues:**
- Consider upgrading to paid tier on hosting platform
- Implement Redis for better performance
- Add MongoDB for persistence and recovery

---

## Cost Estimates

**Free Tier Options:**
- Render: Free (spins down after inactivity, restarts on request)
- Railway: $5 free credit/month
- Heroku: Free tier discontinued, starts at $7/month
- Vercel/Netlify: Free for personal projects

**Recommended for Production:**
- Render Starter: $7/month (always-on)
- Railway: Pay-as-you-go (typically $5-10/month)
- Add MongoDB Atlas Free tier for persistence
- Add Redis (Upstash free tier) for scaling
